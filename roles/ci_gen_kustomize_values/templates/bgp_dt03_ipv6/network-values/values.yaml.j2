---
# source: bgp_dt03_ipv6/network-values/values.yaml.j2
{% set _ipv = cifmw_ci_gen_kustomize_values_ip_version_var_mapping %}
{% set ns = namespace(interfaces={},
                      ocp_index=0,
                      lb_tools={}) %}
data:
{% for host in cifmw_networking_env_definition.instances.keys() -%}
{%   set hostname = cifmw_networking_env_definition.instances[host]['hostname'] %}
{%   for network in cifmw_networking_env_definition.instances[host]['networks'].values() -%}
{%     if 'worker-3' != hostname %}
{%       set ns.interfaces = ns.interfaces |
                             combine({network.network_name: (network.parent_interface |
                                                             default(network.interface_name)
                                                            )
                                     },
                                     recursive=true) -%}
{%     endif %}
{%   endfor -%}
{%   if host is match('^(ocp|crc).*') %}
  node_{{ ns.ocp_index }}:
    name: {{ hostname }}
    node_name: {{ hostname }}.ocp.openstack.lab
{%     for network in cifmw_networking_env_definition.instances[host]['networks'].values() %}
    {{ network.network_name }}_ip: {{ network[_ipv.ip_vX] }}
{%       if 'worker-3' == hostname and 'ctlplane' == network.network_name %}
    base_if: {{ network.interface_name }}
{%       endif %}
{%     endfor %}
{%     set node_bgp_orig_content = original_content.data.bgp.bgpdefs['node' ~ ns.ocp_index] %}
{%     set node_bgp_net0 = node_bgp_orig_content.bgpnet0 %}
{%     if 'worker-3' != hostname %}
{%       set node_bgp_net1 = node_bgp_orig_content.bgpnet1 %}
{%     endif %}
    bgp_peers:
      - {{ node_bgp_net0.bgp_peer }}
{%     if 'worker-3' != hostname %}
      - {{ node_bgp_net1.bgp_peer }}
{%     endif %}
    bgp_ip:
      - {{ node_bgp_net0.bgp_ip }}
{%     if 'worker-3' != hostname %}
      - {{ node_bgp_net1.bgp_ip }}
{%     endif %}
{%     set subnet_index = (hostname | split('-'))[-1] | int %}
{%     set ip_index = 1 if ('master-' in hostname or 'worker-3' == hostname) else 2  %}
{%     set loopback_ip = original_content.data.bgp.subnets.bgpmainnet[subnet_index].allocationRanges[0].start |
                         ansible.utils.ipmath(ip_index) %}
{%     set loopback_ipv6 = original_content.data.bgp.subnets.bgpmainnetv6[subnet_index].allocationRanges[0].start |
                           ansible.utils.ipmath(ip_index) %}
    loopback_ip: {{ loopback_ip }}
    loopback_ipv6: {{ loopback_ipv6 }}
{%     if node_bgp_orig_content.routes | default(false) %}
    routes: {{ node_bgp_orig_content.routes }}
{%     endif %}
{%     set ns.ocp_index = ns.ocp_index+1 %}
{%   endif %}
{% endfor %}

{% for network in cifmw_networking_env_definition.networks.values() %}
{% set ns.lb_tools = {} %}
  {{ network.network_name }}:
    dnsDomain: {{ network.search_domain }}
{%  if network.tools is defined and network.tools.keys() | length > 0 %}
{%    for tool in network.tools.keys() %}
{%      if tool is match('.*lb$') %}
{%        set _ = ns.lb_tools.update({tool: []}) %}
{%      endif %}
{%    endfor %}
{%    if network.tools.netconfig is defined  %}
    subnets:
      - name: subnet1
        cidr: {{ network[_ipv.network_vX] }}
        gateway: {{ omit if network[_ipv.gw_vX] is not defined else network[_ipv.gw_vX] }}
        vlan: {{ omit if network.vlan_id is not defined else network.vlan_id }}
        allocationRanges:
{%      for range in network.tools.netconfig[_ipv.ipvX_ranges] %}
          - end: {{ range.end }}
            start: {{ range.start }}
{%      endfor %}
{%    endif %}
{%    if ns.lb_tools | length > 0 %}
    lb_addresses:
{%      for tool in ns.lb_tools.keys() %}
{%        for lb_range in network.tools[tool][_ipv.ipvX_ranges] %}
      - {{ lb_range.start }}-{{ lb_range.end }}
{%          set _ = ns.lb_tools[tool].append(lb_range.start) %}
{%        endfor %}
    endpoint_annotations:
      {{ tool }}.universe.tf/address-pool: {{ network.network_name }}
      {{ tool }}.universe.tf/allow-shared-ip: {{ network.network_name }}
      {{ tool }}.universe.tf/loadBalancerIPs: {{ ','.join(ns.lb_tools[tool]) }}
{%      endfor %}
{%    endif %}
{%  endif %}
    prefix-length: {{ network[_ipv.network_vX] | ansible.utils.ipaddr('prefix') }}
    mtu: {{ network.mtu | default(1500) }}
{%  if network.vlan_id is defined  %}
    vlan: {{ network.vlan_id }}
    iface: {{ omit if ns.interfaces[network.network_name] is not defined else network.network_name }}
    base_iface: {{ omit if ns.interfaces[network.network_name] is not defined else ns.interfaces[network.network_name] }}
{%  elif network.network_name != "ironic" %}
    iface: {{ omit if ns.interfaces[network.network_name] is not defined else ns.interfaces[network.network_name] }}
{%  else %}
    iface: {{ omit if ns.interfaces[network.network_name] is not defined else network.network_name }}
{%  endif %}
{%  if network.tools.multus is defined and network.network_name == "ctlplane" %}
    net-attach-def: |
      {
        "cniVersion": "0.3.1",
        "name": "{{ network.network_name }}",
        "type": "macvlan",
        "master": "ospbr",
        "ipam": {
          "type": "whereabouts",
          "range": "{{ network[_ipv.network_vX] }}",
          "range_start": "{{ network.tools.multus[_ipv.ipvX_ranges].0.start }}",
          "range_end": "{{ network.tools.multus[_ipv.ipvX_ranges].0.end }}"
        }
      }
{%  endif %}
{%  if network.tools.multus is defined and network.network_name == "ironic" %}
    net-attach-def: |
      {
        "cniVersion": "0.3.1",
        "name": "ironic",
        "type": "bridge",
        "bridge": "ironic",
        "ipam": {
          "type": "whereabouts",
          "range": "{{ network[_ipv.network_vX] }}",
          "range_start": "{{ network.tools.multus[_ipv.ipvX_ranges].0.start }}",
          "range_end": "{{ network.tools.multus[_ipv.ipvX_ranges].0.end }}"
        }
      }
{%  endif %}
{%  if network.tools.multus is defined and network.network_name not in ["ctlplane", "ironic"] %}
    net-attach-def: |
      {
        "cniVersion": "0.3.1",
        "name": "{{ network.network_name }}",
        "type": "macvlan",
        "master": "{{ network.network_name if network.vlan_id is defined else ns.interfaces[network.network_name] }}",
        "ipam": {
          "type": "whereabouts",
          "range": "{{ network[_ipv.network_vX] }}",
          "range_start": "{{ network.tools.multus[_ipv.ipvX_ranges].0.start }}",
          "range_end": "{{ network.tools.multus[_ipv.ipvX_ranges].0.end }}"
        }
      }
{%  endif %}
{% endfor %}
  dns-resolver:
    config:
      server:
        - "{{ cifmw_networking_env_definition.networks.ctlplane[_ipv.gw_vX] }}"
      search: []
    options:
      - key: server
        values:
          - {{ cifmw_networking_env_definition.networks.ctlplane[_ipv.gw_vX] }}
{% for nameserver in cifmw_ci_gen_kustomize_values_nameservers %}
      - key: server
        values:
          - {{ nameserver }}
{% endfor %}

  routes:
    config: []

# Hardcoding the last IP bit since we don't have support for endpoint_annotations in the networking_mapper output
  rabbitmq:
    endpoint_annotations:
      metallb.universe.tf/address-pool: internalapi
      metallb.universe.tf/loadBalancerIPs: {{ cifmw_networking_env_definition.networks['internalapi'][_ipv.network_vX] | ansible.utils.ipmath(85) }}
  rabbitmq-cell1:
    endpoint_annotations:
      metallb.universe.tf/address-pool: internalapi
      metallb.universe.tf/loadBalancerIPs: {{ cifmw_networking_env_definition.networks['internalapi'][_ipv.network_vX] | ansible.utils.ipmath(86) }}

  lbServiceType: LoadBalancer
  storageClass: local-storage
